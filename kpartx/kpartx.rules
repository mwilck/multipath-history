#
# persistent links for device-mapper devices
# only hardware-backed device-mapper devices (ie multipath, dmraid,
# and kpartx) have meaningful persistent device names
#

KERNEL!="dm-*", GOTO="kpartx_end"
ACTION!="add|change", GOTO="kpartx_end"
ENV{DM_UUID}!="?*", GOTO="kpartx_end"

# kpartx_id is very robust, it works for suspended maps and maps
# with 0 dependencies
IMPORT{program}=="kpartx_id %M %m $env{DM_UUID}"

ENV{DM_UDEV_LOW_PRIORITY_FLAG}!="1", OPTIONS+="link_priority=50"

ENV{DM_UUID}=="*mpath-*", ENV{DM_TYPE}=="?*" \
	SYMLINK+="disk/by-id/$env{DM_TYPE}-$env{DM_NAME}"

# Create persistent links for multipath tables
ENV{DM_WWN}=="?*", ENV{DM_PART}!="?*", \
	SYMLINK+="disk/by-id/wwn-$env{DM_WWN}"

# Create persistent links for partitions
ENV{DM_WWN}=="?*", ENV{DM_PART}=="?*", \
	SYMLINK+="disk/by-id/wwn-$env{DM_WWN}-part$env{DM_PART}"

# Create persistent by-label/by-uuid links.
# multipath maps with DM_NOSCAN!=1 are handled in 13-dm-disk.rules.
DM_UUID=="mpath-*", ENV{DM_NOSCAN}!="1", GOTO="symlink_end"

# For partitions, we don't have DM_NOSCAN.
# Simply load variables from db if they aren't set.
# 11-dm-mpath.rules does this for mpath maps.
# Fixme: we have currently no way to avoid calling blkid on
# partitions of broken mpath maps.
ENV{DM_UUID}!="part*-*-*", GOTO="import_end"
ENV{ID_FS_USAGE}!="?*", IMPORT{db}="ID_FS_USAGE"
ENV{ID_FS_UUID_ENC}!="?*", IMPORT{db}="ID_FS_UUID_ENC"
ENV{ID_FS_LABEL_ENC}!="?*", IMPORT{db}="ID_FS_LABEL_ENC"
ENV{ID_PART_ENTRY_NAME}!="?*", IMPORT{db}="ID_PART_ENTRY_NAME"
ENV{ID_PART_ENTRY_UUID}!="?*", IMPORT{db}="ID_PART_ENTRY_UUID"
ENV{ID_PART_ENTRY_SCHEME}!="?*", IMPORT{db}="ID_PART_ENTRY_SCHEME"
LABEL="import_end"

ENV{ID_FS_USAGE}=="filesystem|other|crypto", ENV{ID_FS_UUID_ENC}=="?*", \
       SYMLINK+="disk/by-uuid/$env{ID_FS_UUID_ENC}"
ENV{ID_FS_USAGE}=="filesystem|other", ENV{ID_FS_LABEL_ENC}=="?*", \
       SYMLINK+="disk/by-label/$env{ID_FS_LABEL_ENC}"
ENV{ID_PART_ENTRY_UUID}=="?*", SYMLINK+="disk/by-partuuid/$env{ID_PART_ENTRY_UUID}"
ENV{ID_PART_ENTRY_SCHEME}=="gpt", ENV{ID_PART_ENTRY_NAME}=="?*", \
       SYMLINK+="disk/by-partlabel/$env{ID_PART_ENTRY_NAME}"
LABEL="symlink_end"

# Create dm tables for partitions on multipath devices.
ENV{DM_UUID}!="mpath-?*", GOTO="mpath_kpartx_end"

# DM_SUBSYSTEM_UDEV_FLAG1 is the "skip_kpartx" flag.
# For events not generated by libdevmapper, we need to fetch it from db.
ENV{DM_UDEV_PRIMARY_SOURCE_FLAG}!="1", IMPORT{db}="DM_SUBSYSTEM_UDEV_FLAG1"
ENV{DM_SUBSYSTEM_UDEV_FLAG1}=="1", GOTO="mpath_kpartx_end"

# 11-dm-mpath.rules sets MPATH_UNCHANGED for events that can be ignored.
ENV{MPATH_UNCHANGED}=="1", GOTO="mpath_kpartx_end"

# Don't run kpartx now if we know it will fail or hang.
ENV{DM_SUSPENDED}=="1", GOTO="mpath_kpartx_end"
ENV{DM_NOSCAN}=="1", GOTO="mpath_kpartx_end"

# Run kpartx
GOTO="run_kpartx"
LABEL="mpath_kpartx_end"

## Code for other subsystems (non-multipath) could be placed here ##

GOTO="kpartx_end"

LABEL="run_kpartx"
RUN+="/sbin/kpartx -un -p -part /dev/$name"

LABEL="kpartx_end"
